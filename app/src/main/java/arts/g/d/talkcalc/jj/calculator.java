/* calculator.java */
/* Generated By:JavaCC: Do not edit this line. calculator.java */
package arts.g.d.talkcalc.jj;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

import java.io.PrintStream ;
public class calculator implements calculatorConstants {
        public class DLValue {
                double floatValue;
                long   intValue;
                boolean bIsFloat;
                boolean bIsDate;
                boolean bIsError;
                boolean bIsBitOverflow;
                String errorString;

                public DLValue()
                {
                        init();
                }

                public DLValue(long value)
                {
                        set(value);
                }

                public DLValue(int value)
                {
                        set(value);
                }

                public DLValue(float value)
                {
                        set(value);
                }

                public DLValue(double value)
                {
                        set(value);
                }

                public void init()
                {
                        floatValue = 0.0;
                        intValue = 0;
                        bIsFloat = true;
                        bIsDate = false;
                        bIsError = false;
                        errorString = "";
                        bIsBitOverflow = false;
                }

                public void setLong(boolean value)
                {
                        bIsFloat = value;
                }
                public void set(long value)
                {
                        intValue = value;
                        bIsFloat = false;
                }
                public void set(int value)
                {
                        intValue = (long)value;
                        bIsFloat = false;
                }

                public void set(float value)
                {
                        floatValue = (double)value;
                        bIsFloat = true;
                }

                public void set(double value)
                {
                        floatValue = value;
                        bIsFloat = true;
                }
                public boolean getIsFloat()
                {
                        return bIsFloat;
                }

                public void sync()
                {
                        if( !bIsFloat ){
                                floatValue = intValue;
                        }else{
                                intValue = (long)floatValue;
                        }
                }

                public void upSync()
                {
                        sync();
                        if( !bIsFloat ){
                                bIsFloat = true;
                                bIsDate = false;
                        }
                }
                public void up()
                {
                        bIsDate = false;
                        bIsFloat = true;
                }
                public void down()
                {
                        bIsFloat = false;
                }
                public double getFloatValue()
                {
                        return floatValue;
                }

                public long getIntValue()
                {
                        return intValue;
                }

                public void print()
                {
                        if( bIsError ){
                                System.out.println("Error:"+errorString);
                                return;
                        }
                        if( bIsBitOverflow ){
                                System.out.println("Overflow:"+errorString);
                        }
                        if( bIsFloat ){
                                System.out.println(getFloatValue());
                        }else{
                                System.out.println(getIntValue());
                                if( bIsDate ){
                                        SimpleDateFormat dateFormat = new  SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                                        dateFormat.setTimeZone(TimeZone.getTimeZone( "GMT+0" ));
                                        Date date = new Date(getIntValue());
                                        String strDate = dateFormat.format(date);
                                        System.out.println(strDate);
                                }
                        }
                }

                public DLValue parse(String str)
                {
                        long valuelong = 0;
                        double valuedouble = 0.0;
                        int radix = 10;
                        String newstr = str;
                        if(str.length() > 2 && str.charAt(0)=='0' && str.charAt(1)=='x' ){
                                newstr = str.substring(2,str.length());
                                radix = 16;
                                newstr = newstr.trim().replaceAll(" ", "");
                                newstr = newstr.replaceAll("\\p{Z}", "");
                        }else if(str.length()>1 && str.charAt(str.length()-1)=='b'){
                                // remove a last 'b' char 
                                newstr = str.substring(0,str.length()-1);
                                radix = 2;
                                newstr = newstr.trim().replaceAll(" ", "");
                                newstr = newstr.replaceAll("\\p{Z}", "");
                        }
                        if( radix == 10 ){
                                try{
                                        valuelong = Long.parseLong(newstr, radix);
                                        set(valuelong);
                                        return new DLValue(valuelong);
                                }catch(NumberFormatException nfe){
                                        try{
                                                valuedouble = Double.parseDouble(newstr);
                                        }catch(NumberFormatException nfe2){
                                                errorString = "NumberFormatException";
                                                bIsError = true;
                                                return new DLValue(0);
                                        }
                                        set(valuedouble);
                                        return new DLValue(valuedouble);
                                }
                        }else{
                                try{
                                        valuelong = Long.parseLong(newstr, radix);
                                }catch(NumberFormatException nfe2){
                                        errorString = "NumberFormatException";
                                        bIsError = true;
                                        return new DLValue(0);
                                }
                                set(valuelong);
                                return new DLValue(valuelong);
                        }
                }

                public DLValue function(String type, String input1, String input2)
                {
                        if("date".equals(type)){
                                SimpleDateFormat dateFormat = new  SimpleDateFormat(input1, java.util.Locale.getDefault());
                                dateFormat.setTimeZone(TimeZone.getTimeZone( "GMT+0" ));
                                Date date;
                                try {
                                        date = dateFormat.parse(input2);
                                } catch (Exception e) {
                                        errorString = "date function Error";
                                        bIsError = true;
                                        return this;
                                }
                                set(date.getTime());
                                bIsDate = true;
                        }
                        return this;
                }
                public long getFactorial(long number) {
                        long factorial = 1;
                        for (long i = 1; i <= number; ++i) {
                                factorial *= i;
                        }
                        return factorial;
                }
                public DLValue function(String type)
                {
                        if("PI".equals(type)){
                                up();
                                floatValue = Math.PI;
                        }else if("E".equals(type)){
                                up();
                                floatValue = Math.E;
                        }else if("~".equals(type)){
                                if( bIsFloat ){
                                        errorString = "overflow";
                                        bIsError = true;
                                        return this;
                                }
                                intValue = ~intValue;
                        }else if("!".equals(type)){
                                if( bIsFloat || (intValue > 20)){
                                        errorString = "overflow";
                                        bIsError = true;
                                        return this;
                                }
                                intValue = getFactorial(intValue);
                        }
                        return this;
                }

                public DLValue function(String type, DLValue input1, DLValue input2)
                {
                        sync();
                        input1.sync();
                        input2.sync();
                        if("pow".equals(type)){
                                up();
                                input1.up();
                                input2.up();
                                floatValue = Math.pow(input1.getFloatValue(),input2.getFloatValue());
                        }else if("atan2".equals(type)){
                                up();
                                input1.up();
                                input2.up();
                                floatValue = Math.atan2( input1.getFloatValue(),input2.getFloatValue());
                        }else if("max".equals(type)){
                                floatValue = Math.max( input1.getFloatValue(),input2.getFloatValue());
                                intValue = Math.max( input1.getIntValue(),input2.getIntValue() );
                        }else if("min".equals(type)){
                                floatValue = Math.min( input1.getFloatValue(),input2.getFloatValue());
                                intValue = Math.min( input1.getIntValue(),input2.getIntValue() );
                        }else if("hypot".equals(type)){
                                up();
                                input1.up();
                                input2.up();
                                floatValue = Math.hypot( input1.getFloatValue(),input2.getFloatValue());
                        }

                        if( !bIsFloat )
                        {
                                // Integer
                                if( floatValue - intValue > 1.0E-16 ) {
                                        // If difference is greater than 1d, must change type to the float
                                        up();
                                }
                        }
                        return this;
                }

                public DLValue function(String type, DLValue input1)
                {
                        boolean isFloat = bIsFloat | input1.getIsFloat();
                        boolean onlyInt = false;
                        sync();
                        input1.sync();

                        if( isFloat ) {
                                upSync();
                                input1.upSync();
                        }

                        if("+".equals(type)){
                                floatValue = floatValue + input1.getFloatValue();
                                intValue = intValue + input1.getIntValue();
                        }else if("-".equals(type)){
                                floatValue = floatValue - input1.getFloatValue();
                                intValue = intValue - input1.getIntValue();
                        }else if("*".equals(type)){
                                floatValue = floatValue * input1.getFloatValue();
                                intValue = intValue * input1.getIntValue();
                        }else if("/".equals(type)){
                                floatValue = floatValue / input1.getFloatValue();
                                intValue = intValue / input1.getIntValue();
                        }else if("sin".equals(type)){
                                up();
                                floatValue = Math.sin( input1.getFloatValue() );
                        }else if("cos".equals(type)){
                                up();
                                floatValue = Math.cos( input1.getFloatValue() );
                        }else if("tan".equals(type)){
                                up();
                                floatValue = Math.tan( input1.getFloatValue() );
                        }else if("asin".equals(type)){
                                up();
                                floatValue = Math.asin( input1.getFloatValue() );
                        }else if("acos".equals(type)){
                                up();
                                floatValue = Math.acos( input1.getFloatValue() );
                        }else if("atan".equals(type)){
                                up();
                                floatValue = Math.atan( input1.getFloatValue() );
                        }else if("toRadians".equals(type)){
                                up();
                                floatValue = Math.toRadians( input1.getFloatValue() );
                        }else if("toDegrees".equals(type)){
                                up();
                                floatValue = Math.toDegrees( input1.getFloatValue() );
                        }else if("exp".equals(type)){
                                up();
                                floatValue = Math.exp( input1.getFloatValue() );
                        }else if("log".equals(type)){
                                up();
                                floatValue = Math.log( input1.getFloatValue() );
                        }else if("log10".equals(type)){
                                up();
                                floatValue = Math.log10( input1.getFloatValue() );
                        }else if("sqrt".equals(type)){
                                up();
                                floatValue = Math.sqrt( input1.getFloatValue() );
                        }else if("cbrt".equals(type)){
                                up();
                                floatValue = Math.cbrt( input1.getFloatValue() );
                        }else if("ceil".equals(type)){
                                up();
                                floatValue = Math.ceil( input1.getFloatValue() );
                        }else if("floor".equals(type)){
                                up();
                                floatValue = Math.floor( input1.getFloatValue() );
                        }else if("rint".equals(type)){
                                up();
                                floatValue = Math.rint( input1.getFloatValue() );
                        }else if("abs".equals(type)){
                                floatValue = Math.abs( input1.getFloatValue() );
                                intValue = Math.abs( input1.getIntValue() );
                        }else if("signum".equals(type)){
                                up();
                                floatValue = Math.signum( input1.getFloatValue() );
                        }else if("sinh".equals(type)){
                                up();
                                floatValue = Math.sinh( input1.getFloatValue() );
                        }else if("cosh".equals(type)){
                                up();
                                floatValue = Math.cosh( input1.getFloatValue() );
                        }else if("tanh".equals(type)){
                                up();
                                floatValue = Math.tanh( input1.getFloatValue() );
                        }else if("|".equals(type)){
                                if( bIsFloat ){
                                        errorString = "float type is not support";
                                        bIsError = true;
                                        return this;
                                }
                                intValue = intValue | input1.getIntValue();
                                onlyInt = true;
                        }else if("^".equals(type)){
                                if( bIsFloat ){
                                        errorString = "float type is not support";
                                        bIsError = true;
                                        return this;
                                }
                                intValue = intValue ^ input1.getIntValue();
                                onlyInt = true;
                        }else if("&".equals(type)){
                                if( bIsFloat ){
                                        errorString = "float type is not support";
                                        bIsError = true;
                                        return this;
                                }
                                intValue = intValue & input1.getIntValue();
                                onlyInt = true;
                        }else if(">>".equals(type)){
                                if( bIsFloat ){
                                        errorString = "float type is not support";
                                        bIsError = true;
                                        return this;
                                }
                                intValue = intValue >> input1.getIntValue();
                                onlyInt = true;
                        }else if("<<".equals(type)){
                                if( bIsFloat ){
                                        errorString = "float type is not support";
                                        bIsError = true;
                                        return this;
                                }
                                intValue = intValue << input1.getIntValue();
                                floatValue = floatValue * Math.pow( 2, input1.getIntValue());
                                if( floatValue - intValue > 1.0E-20 ) {
                                        // If difference is greater than 1d, must change type to the float
                                        bIsBitOverflow = true;
                                        errorString = "<<";
                                }
                                onlyInt = true;
                        }else if("%".equals(type)){
                                if( bIsFloat ){
                                        errorString = "float type is not support";
                                        bIsError = true;
                                        return this;
                                }
                                intValue = intValue % input1.getIntValue();
                                onlyInt = true;
                        }

                        if( !isFloat && !onlyInt )
                        {
                                // Integer
                                if( floatValue - intValue > 1.0E-20 ) {
                                        // If difference is greater than 1d, must change type to the float
                                        up();
                                }
                        }

                        return this;
                }
        }


        static DLValue previousValue,thisValue;
        public static void main(String args[]) throws ParseException {
                calculator parser = new calculator(System.in);
                while (true) {
                        System.out.println("This is an advanced calculator based on the prior .jj embeded in eclipse");
                        System.out.print("Enter an expression like \"2.0+3.4 \" we support +,-,*,\\,(),sin(),cos(),and number with fraction:");
                        try {
                                parser.Start(System.out);
                        } catch (Exception e) {
                                System.out.println("NOK.");
                                System.out.println(e.getMessage());
                                parser.ReInit(System.in);
                        } catch (Error e) {
                                System.out.println("Oops.");
                                System.out.println(e.getMessage());
                                break;
                        }
                }
        }

        public static String calc(java.io.InputStream stream) {
                String ret;
                calculator parser = new calculator(stream);
                try{
                        parser.Start(System.out);
                } catch (Exception e) {
                        ret = "NOK\n" + e.getMessage();
                        return ret;
                } catch (Error e) {
                        ret = "Ooops\n" + e.getMessage();
                        return ret;
                }

                if( previousValue.bIsError ){
                        ret = "Error:"+previousValue.errorString;
                        return ret;
                }
                if( previousValue.bIsBitOverflow ){
                        ret = "Overflow:"+previousValue.errorString;
                        return ret;
                }
                if( previousValue.bIsFloat ){
                        ret = ""+previousValue.getFloatValue();
                }else{
                        ret = ""+previousValue.getIntValue();
                        if( previousValue.bIsDate ){
                                SimpleDateFormat dateFormat = new  SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                                dateFormat.setTimeZone(TimeZone.getTimeZone( "GMT+0" ));
                                Date date = new Date(previousValue.getIntValue());
                                String strDate = dateFormat.format(date);
                                ret += "\n";
                                ret += strDate;
                        }
                }
                return ret;
        }

  final public void Start(PrintStream printStream) throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:
      case NOT:
      case LPAREN:
      case INTEGER_NUMBER:
      case FLOATING_NUMBER:
      case SIN:
      case COS:
      case TAN:
      case ASIN:
      case ACOS:
      case ATAN:
      case TORADIANS:
      case TODEGREES:
      case EXP:
      case LOG:
      case LOG10:
      case SQRT:
      case CBRT:
      case CEIL:
      case FLOOR:
      case RINT:
      case ABS:
      case SIGNUM:
      case SINH:
      case COSH:
      case TANH:
      case POW:
      case ATAN2:
      case MAX:
      case MIN:
      case HYPOT:
      case PI:
      case MATH_E:
      case DATE:
      case FDATE:
      case HEX_NUMBER:
      case BIN_NUMBER:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      thisValue = or_bit();
      jj_consume_token(EOL);
thisValue.print(); previousValue = thisValue;
    }
    jj_consume_token(0);
  }

  final public DLValue or_bit() throws ParseException {DLValue i;
  DLValue value;
    value = xor_bit();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OR_BIT:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      jj_consume_token(OR_BIT);
      i = xor_bit();
value.function("|",i);
    }
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
  }

  final public DLValue xor_bit() throws ParseException {DLValue i;
  DLValue value;
    value = and_bit();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case XOR_BIT:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_3;
      }
      jj_consume_token(XOR_BIT);
      i = and_bit();
value.function("^",i);
    }
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
  }

  final public DLValue and_bit() throws ParseException {DLValue i;
  DLValue value;
    value = shift_bit();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND_BIT:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_4;
      }
      jj_consume_token(AND_BIT);
      i = shift_bit();
value.function("&",i);
    }
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
  }

  final public DLValue shift_bit() throws ParseException {DLValue i;
  DLValue value;
    value = sum();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RSHIFT_BIT:
      case LSHIFT_BIT:{
        ;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RSHIFT_BIT:{
        jj_consume_token(RSHIFT_BIT);
        i = sum();
value.function(">>",i);
        break;
        }
      case LSHIFT_BIT:{
        jj_consume_token(LSHIFT_BIT);
        i = sum();
value.function("<<",i);
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
  }

  final public DLValue sum() throws ParseException {DLValue i;
  DLValue value;
    value = term();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        ;
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        jj_consume_token(PLUS);
        i = term();
value.function("+",i);
        break;
        }
      case MINUS:{
        jj_consume_token(MINUS);
        i = term();
value.function("-",i);
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
  }

  final public DLValue term() throws ParseException {DLValue i;
  DLValue value;
    value = Primary();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
      case MOD:{
        ;
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULTIPLY:{
        jj_consume_token(MULTIPLY);
        i = Primary();
value.function("*",i);
        break;
        }
      case DIVIDE:{
        jj_consume_token(DIVIDE);
        i = Primary();
value.function("/",i);
        break;
        }
      case MOD:{
        jj_consume_token(MOD);
        i = Primary();
value.function("%",i);
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return value ;}
    throw new Error("Missing return statement in function");
  }

  final public String string() throws ParseException {Token t ;
    t = jj_consume_token(STRING);
{if ("" != null) return new String(t.image);}
    throw new Error("Missing return statement in function");
  }

  final public DLValue Primary() throws ParseException {Token t ;
  String a,b ;
  DLValue value,value2;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BIN_NUMBER:{
      t = jj_consume_token(BIN_NUMBER);
{if ("" != null) return new DLValue().parse(t.image);}
      break;
      }
    case HEX_NUMBER:{
      t = jj_consume_token(HEX_NUMBER);
{if ("" != null) return new DLValue().parse(t.image);}
      break;
      }
    case INTEGER_NUMBER:{
      t = jj_consume_token(INTEGER_NUMBER);
{if ("" != null) return new DLValue().parse(t.image);}
      break;
      }
    case FLOATING_NUMBER:{
      t = jj_consume_token(FLOATING_NUMBER);
{if ("" != null) return new DLValue(Double.parseDouble( t.image )) ;}
      break;
      }
    case PI:{
      jj_consume_token(PI);
{if ("" != null) return new DLValue().function("PI");}
      break;
      }
    case MATH_E:{
      jj_consume_token(MATH_E);
{if ("" != null) return new DLValue().function("E");}
      break;
      }
    case LPAREN:{
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value ;}
      break;
      }
    case NOT:{
      jj_consume_token(NOT);
      value = Primary();
{if ("" != null) return value.function("~");}
      break;
      }
    case PLUS:{
      jj_consume_token(PLUS);
      value = Primary();
{if ("" != null) return value;}
      break;
      }
    case MINUS:{
      jj_consume_token(MINUS);
      value = Primary();
{if ("" != null) return value.function("*",new DLValue(-1)) ;}
      break;
      }
    case SIN:{
      jj_consume_token(SIN);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("sin",value);}
      break;
      }
    case COS:{
      jj_consume_token(COS);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("cos",value);}
      break;
      }
    case TAN:{
      jj_consume_token(TAN);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("tan",value);}
      break;
      }
    case ASIN:{
      jj_consume_token(ASIN);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("asin",value);}
      break;
      }
    case ACOS:{
      jj_consume_token(ACOS);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("acos",value);}
      break;
      }
    case ATAN:{
      jj_consume_token(ATAN);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("atan",value);}
      break;
      }
    case TORADIANS:{
      jj_consume_token(TORADIANS);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("toRadians",value);}
      break;
      }
    case TODEGREES:{
      jj_consume_token(TODEGREES);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("toDegrees",value);}
      break;
      }
    case EXP:{
      jj_consume_token(EXP);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("exp",value);}
      break;
      }
    case LOG:{
      jj_consume_token(LOG);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("log",value);}
      break;
      }
    case LOG10:{
      jj_consume_token(LOG10);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("log10",value);}
      break;
      }
    case SQRT:{
      jj_consume_token(SQRT);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("sqrt",value);}
      break;
      }
    case CBRT:{
      jj_consume_token(CBRT);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("cbrt",value);}
      break;
      }
    case CEIL:{
      jj_consume_token(CEIL);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("ceil",value);}
      break;
      }
    case FLOOR:{
      jj_consume_token(FLOOR);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("floor",value);}
      break;
      }
    case RINT:{
      jj_consume_token(RINT);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("rint",value);}
      break;
      }
    case ABS:{
      jj_consume_token(ABS);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("abs",value);}
      break;
      }
    case SIGNUM:{
      jj_consume_token(SIGNUM);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("signum",value);}
      break;
      }
    case SINH:{
      jj_consume_token(SINH);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("sinh",value);}
      break;
      }
    case COSH:{
      jj_consume_token(COSH);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("cosh",value);}
      break;
      }
    case TANH:{
      jj_consume_token(TANH);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("tanh",value);}
      break;
      }
    case POW:{
      jj_consume_token(POW);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(COMMA);
      value2 = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("pow",value,value2);}
      break;
      }
    case ATAN2:{
      jj_consume_token(ATAN2);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(COMMA);
      value2 = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("atan2",value,value2);}
      break;
      }
    case MAX:{
      jj_consume_token(MAX);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(COMMA);
      value2 = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("max",value,value2);}
      break;
      }
    case MIN:{
      jj_consume_token(MIN);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(COMMA);
      value2 = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("min",value,value2);}
      break;
      }
    case HYPOT:{
      jj_consume_token(HYPOT);
      jj_consume_token(LPAREN);
      value = or_bit();
      jj_consume_token(COMMA);
      value2 = or_bit();
      jj_consume_token(RPAREN);
{if ("" != null) return value.function("hypot",value,value2);}
      break;
      }
    case DATE:{
      jj_consume_token(DATE);
      jj_consume_token(LPAREN);
      a = string();
      jj_consume_token(RPAREN);
{if ("" != null) return new DLValue().function("date", "\"yyyy-MM-dd HH:mm:ss\"", a);}
      break;
      }
    case FDATE:{
      jj_consume_token(FDATE);
      jj_consume_token(LPAREN);
      a = string();
      jj_consume_token(COMMA);
      b = string();
      jj_consume_token(RPAREN);
{if ("" != null) return new DLValue().function("date", a, b);}
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public calculatorTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[11];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfffdb180,0x4,0x8,0x10,0x60,0x60,0x180,0x180,0xe00,0xe00,0xfffdb180,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x6ffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6ffff,};
   }

  /** Constructor with InputStream. */
  public calculator(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public calculator(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new calculatorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public calculator(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new calculatorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
      jj_input_stream = new SimpleCharStream(stream, 1, 1);
   } else {
      jj_input_stream.ReInit(stream, 1, 1);
   }
   if (token_source == null) {
      token_source = new calculatorTokenManager(jj_input_stream);
   }

    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public calculator(calculatorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(calculatorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[55];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 11; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 55; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
/*
 ORDER
 () , function, ~, +, - : Primary
 * / % : ?��?�� term
 + - : �?�? sum
 << >> : shift bit
 & : and bit
 ^ : xor bit
 | : or bit
 */

